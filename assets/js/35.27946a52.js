(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{441:function(e,t,s){"use strict";s.r(t);var a=s(2),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("我们都知道"),t("code",[e._v("JavaScript")]),e._v("是执行环境为“单线程”语言。这样虽然实现比较简单，但一旦有一个耗时特别长的任务，就会阻碍整个程序的正常运行。就跟超市收银只有一个队一样，前面有人买了一大堆东西，后面的人只能等他，整体的进度就被拖慢了。那该怎么解决这种问题呢？答案是"),t("code",[e._v("异步编程")]),e._v("。按前面那个例子来看，就是咱把东西多的人分到第二队去，就是"),t("code",[e._v("同步")]),e._v("的代码正常执行，"),t("code",[e._v("异步")]),e._v("的先到旁边自己执行（不按照代码顺序去执行），最后程序的执行时间大大减少。那么，"),t("code",[e._v("异步编程")]),e._v("有几种方案呢？一就是"),t("strong",[e._v("回调函数")]),e._v("，二就是本文讲的"),t("code",[e._v("Promise")])]),e._v(" "),t("h2",{attrs:{id:"promise-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象"}},[e._v("#")]),e._v(" Promise 对象")]),e._v(" "),t("h3",{attrs:{id:"什么是-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-promise"}},[e._v("#")]),e._v(" 什么是 Promise")]),e._v(" "),t("p",[e._v("所谓"),t("code",[e._v("Promise")]),e._v("，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 ---------- "),t("strong",[e._v("《ES6 入门教程》")])]),e._v(" "),t("h3",{attrs:{id:"promise-的基本用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-的基本用法"}},[e._v("#")]),e._v(" Promise 的基本用法")]),e._v(" "),t("p",[t("strong",[e._v("语法：")]),e._v(" "),t("code",[e._v("const a=new Promise((resolve,reject)=>{})")])]),e._v(" "),t("p",[t("strong",[e._v("参数：")]),e._v(" "),t("code",[e._v("Promise")]),e._v("接收两个函数作为参数，一个是"),t("code",[e._v("resolve")]),e._v("，作用是将"),t("code",[e._v("Promise")]),e._v("对象的状态从"),t("code",[e._v("Pending")]),e._v("转为"),t("code",[e._v("fulfilled")]),e._v("，并将异步操作的结果（可以是值，也可以是另一个"),t("code",[e._v("Promise")]),e._v("对象）作为结果传递出去。一个是"),t("code",[e._v("reject")]),e._v("，作用是将从"),t("code",[e._v("Pending")]),e._v("转为"),t("code",[e._v("rejected")]),e._v("，将抛出的错误传递出去。")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("Promise")]),e._v("有三种状态："),t("code",[e._v("Pending")]),e._v(","),t("code",[e._v("fulfilled")]),e._v(","),t("code",[e._v("rejected")])]),e._v(" "),t("p",[e._v("且只有两种转换方式")]),e._v(" "),t("p",[e._v("1."),t("code",[e._v("Pending")]),e._v("=>"),t("code",[e._v("fulfilled")])]),e._v(" "),t("p",[e._v("2."),t("code",[e._v("Pending")]),e._v("=>"),t("code",[e._v("rejected")])])]),e._v(" "),t("p",[t("strong",[e._v("基本使用：")])]),e._v(" "),t("p",[e._v("1 .resolve：")]),e._v(" "),t("p",[e._v("首先"),t("code",[e._v("then")]),e._v("的作用是为 "),t("code",[e._v("Promise")]),e._v(" 实例添加状态改变时的回调函数，并且"),t("code",[e._v("then")]),e._v("方法的第一个参数是"),t("code",[e._v("fulfilled")]),e._v("状态的回调函数，第二个参数是"),t("code",[e._v("rejected")]),e._v("状态的回调函数，它们都是可选的。")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("resolve"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" reject")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("resolve")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//同步执行并向外部传递异步操作的结果")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("fulfilled")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("fulfilled"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//等所有同步代码执行完按异步队列先后顺序去执行")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//1")]),e._v("\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("reject：")])]),e._v(" "),t("p",[t("code",[e._v("catch()")]),e._v("方法是"),t("code",[e._v("then(null, rejection)")]),e._v("或"),t("code",[e._v("then(undefined, rejection)")]),e._v("的别名，用于指定发生错误时的回调函数。在"),t("code",[e._v("reject")]),e._v("抛出错误，或运行出现错误时都会调用此方法的回调函数。")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("resolve"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" reject")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("reject")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Error")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'error'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("catch")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("rejected")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rejected"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//Error: error......")]),e._v("\n")])])]),t("h3",{attrs:{id:"promise-的其他方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-的其他方法"}},[e._v("#")]),e._v(" Promise 的其他方法")]),e._v(" "),t("p",[t("code",[e._v("Promise.prototype.finally()")]),e._v(":用法为不管 Promise 对象最后状态如何，都会执行指定操作")]),e._v(" "),t("p",[t("code",[e._v("Promise.all()")]),e._v("：将多个 "),t("code",[e._v("Promise")]),e._v("实例，包装成一个新的 Promise 实例，只有当其中所有的"),t("code",[e._v("Promise")]),e._v("实例状态皆为"),t("code",[e._v("fulfilled")]),e._v("新的实例才会变为"),t("code",[e._v("fulfilled")])]),e._v(" "),t("p",[t("code",[e._v("Promise.race()")]),e._v("：同样将多个"),t("code",[e._v("Promise")]),e._v(" 实例，包装成一个新的 Promise 实例。但只要有一个"),t("code",[e._v("Promise")]),e._v(" 实例状态改变，新的实例便跟着改变")]),e._v(" "),t("h2",{attrs:{id:"promise-的几个关键问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-的几个关键问题"}},[e._v("#")]),e._v(" promise 的几个关键问题")]),e._v(" "),t("h3",{attrs:{id:"如何改变-promise-的状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何改变-promise-的状态"}},[e._v("#")]),e._v(" 如何改变 promise 的状态?")]),e._v(" "),t("p",[e._v("(1)"),t("code",[e._v("resolve(fulfilled)")]),e._v(": 如果当前是 "),t("code",[e._v("pending")]),e._v(" 就会变为 resolved")]),e._v(" "),t("p",[e._v("(2)"),t("code",[e._v("reject(rejected)")]),e._v(": 如果当前是"),t("code",[e._v("pending")]),e._v(" 就会变为 "),t("code",[e._v("rejected")])]),e._v(" "),t("p",[e._v("(3) 抛出异常: 如果当前是 "),t("code",[e._v("pending")]),e._v(" 就会变为 "),t("code",[e._v("rejected")])]),e._v(" "),t("h3",{attrs:{id:"一个-promise-指定多个成功-失败回调函数-都会调用吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个-promise-指定多个成功-失败回调函数-都会调用吗"}},[e._v("#")]),e._v(" 一个 promise 指定多个成功/失败回调函数, 都会调用吗?")]),e._v(" "),t("p",[e._v("当 promise 改变为对应状态时都会调用")]),e._v(" "),t("h3",{attrs:{id:"改变-promise-状态和指定回调函数谁先谁后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#改变-promise-状态和指定回调函数谁先谁后"}},[e._v("#")]),e._v(" 改变 promise 状态和指定回调函数谁先谁后?")]),e._v(" "),t("p",[e._v("(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调")]),e._v(" "),t("p",[e._v("(2) 如何先改状态再指定回调?")]),e._v(" "),t("p",[e._v("① 在执行器中直接调用 "),t("code",[e._v("resolve()")]),e._v("/"),t("code",[e._v("reject()")])]),e._v(" "),t("p",[e._v("② 延迟更长时间才调用"),t("code",[e._v("then()")])]),e._v(" "),t("p",[e._v("(3) 什么时候才能得到数据?")]),e._v(" "),t("p",[e._v("① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据")]),e._v(" "),t("p",[e._v("② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据")]),e._v(" "),t("h3",{attrs:{id:"promise-then-返回的新-promise-的结果状态由什么决定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-then-返回的新-promise-的结果状态由什么决定"}},[e._v("#")]),e._v(" promise.then()返回的新 promise 的结果状态由什么决定?")]),e._v(" "),t("p",[e._v("(1) 简单表达: 由 "),t("code",[e._v("then()")]),e._v("指定的回调函数执行的结果决定")]),e._v(" "),t("p",[e._v("(2) 详细表达:")]),e._v(" "),t("p",[e._v("① 如果抛出异常, 新 "),t("code",[e._v("promise")]),e._v("变为"),t("code",[e._v("rejected,")]),e._v(" "),t("code",[e._v("rejected")]),e._v("为抛出的异常")]),e._v(" "),t("p",[e._v("② 如果返回的是非 "),t("code",[e._v("promise")]),e._v(" 的任意值, 新 "),t("code",[e._v("promise")]),e._v(" 变为"),t("code",[e._v("resolved")]),e._v(", "),t("code",[e._v("fulfilled")]),e._v("为返回的值")]),e._v(" "),t("p",[e._v("③ 如果返回的是另一个新 "),t("code",[e._v("promise")]),e._v(", 此 "),t("code",[e._v("promise")]),e._v(" 的结果就会成为新 "),t("code",[e._v("promise")]),e._v(" 的结果")]),e._v(" "),t("h3",{attrs:{id:"promise-如何串连多个操作任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-如何串连多个操作任务"}},[e._v("#")]),e._v(" promise 如何串连多个操作任务?")]),e._v(" "),t("p",[e._v("(1) "),t("code",[e._v("promise")]),e._v(" 的 "),t("code",[e._v("then()")]),e._v("返回一个新的 "),t("code",[e._v("promise")]),e._v(", 可以继续 "),t("code",[e._v("then()")]),e._v("的链式调用")]),e._v(" "),t("p",[e._v("(2) 通过 "),t("code",[e._v("then()")]),e._v(" 的链式调用串连多个异步任务")]),e._v(" "),t("h3",{attrs:{id:"promise-异常穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-异常穿透"}},[e._v("#")]),e._v(" promise 异常穿透?")]),e._v(" "),t("p",[e._v("(1) 当使用 "),t("code",[e._v("promise")]),e._v(" 的 "),t("code",[e._v("then()")]),e._v(" 链式调用时, 可以在最后指定失败的回调,")]),e._v(" "),t("p",[e._v("(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理")]),e._v(" "),t("h3",{attrs:{id:"中断-promise-链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中断-promise-链"}},[e._v("#")]),e._v(" 中断 promise 链?")]),e._v(" "),t("p",[e._v("(1) 当使用 "),t("code",[e._v("promise")]),e._v(" 的 "),t("code",[e._v("then()")]),e._v(" 链式调用时, 在中间中断, 不再调用后面的回调函数")]),e._v(" "),t("p",[e._v("(2) 办法: 在回调函数中返回一个 "),t("code",[e._v("pending")]),e._v(" 状态的 "),t("code",[e._v("promise")]),e._v(" 对象")])])}),[],!1,null,null,null);t.default=r.exports}}]);