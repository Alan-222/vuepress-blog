(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{451:function(t,e,r){"use strict";r.r(e);var a=r(2),s=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("我们知道 Vue 中父组件与子组件之间的传值可通过子组件标签传值+props 很容易实现，子传父可通过事件总线或父组件使用子组件的引用 ref 调用子组件的方法来获取子组件的数据，还有很多方法，这里就不再列举了。但是，兄弟间或者更多层次的传递怎么实现呢？这里笔者将教大家"),e("strong",[t._v("Vuex")]),t._v("的基本使用方法去实现。")]),t._v(" "),e("h2",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),e("p",[t._v("首先，先跟大家介绍一下"),e("strong",[t._v("Vuex")]),t._v("的概念。它是一种在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。我们下面来看一下原理图")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37ddc7c462ba4b25bff61bf52c27c159~tplv-k3u1fbpfcp-watermark.image?",alt:"vuex.png"}})]),t._v(" "),e("p",[t._v("我们可以发现 VC 也就是组件实例一般是经过分发 dispatch 到 Vuex 中的 actions 再 commit 提交到 mutations 中最终修改 state 中的数据。但若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写"),e("code",[t._v("dispatch")]),t._v("，直接编写"),e("code",[t._v("commit")]),t._v("。空口无凭，下面我们通过一个小案例来理解一下。")]),t._v(" "),e("h2",{attrs:{id:"搭建环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#搭建环境"}},[t._v("#")]),t._v(" 搭建环境")]),t._v(" "),e("p",[t._v("1.下载 Vuex")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("npm  i  vuex\n")])])]),e("p",[t._v("2.创建文件夹与文件"),e("strong",[t._v("src/store/index.js")])]),t._v(" "),e("p",[e("strong",[t._v("目录结构：")])]),t._v(" "),e("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f46d989395b4249aaaba84e4af9cff4~tplv-k3u1fbpfcp-watermark.image?",alt:"img.png",referrerpolicy:"no-referrer"}}),t._v(" "),e("p",[e("strong",[t._v("index.js:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//引入Vue核心库\nimport Vue from 'vue'\n//引入Vuex\nimport Vuex from 'vuex'\n//应用Vuex插件\nVue.use(Vuex)\n​\n//准备actions对象——响应组件中用户的动作\nconst actions = {}\n//准备mutations对象——修改state中的数据\nconst mutations = {}\n//准备state对象——保存具体的数据\nconst state = {}\n​\n//创建并暴露store\nexport default new Vuex.Store({\n    actions,\n    mutations,\n    state\n})\n")])])]),e("p",[t._v("3.在 main.js 文件中引入 store 并在 Vue 实例中使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import Vue from 'vue';\nimport App from './App.vue';\n//引入Vuex配置文件store\nimport store from './store';\n//引入VueRouter\nimport VueRouter from 'vue-router';\n//引入路由器\nimport router from './router';\nVue.config.productionTip = false;\nVue.use(VueRouter);\nconst vm = new Vue({\n  render: (h) => h(App),\n  store,\n  router\n}).$mount('#app');\n")])])]),e("h2",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),e("p",[t._v("现在比如说我有一个 brother1 和 brother2 组件分别都有各自的数据。")]),t._v(" "),e("p",[e("strong",[t._v("brother1.vue:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(' gameList: ["英雄联盟", "绝地求生", "永劫无间", "Dread Hunger"],\n')])])]),e("p",[e("strong",[t._v("brother2.vue:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("peopleList: ['张三', '李四', '王五', '陆六'];\n")])])]),e("p",[t._v("现在如果这两个组件的列表要实现共用，我们可以把这两个列表统一保存到 store.js 文件中的 state 中。然后现在要展示列表可以在 brother1.vue 的计算属性中返回 state 中的数据（brother2 同理），也可直接模板中调用（这样若多次使用得重复写大段名称）。")]),t._v(" "),e("p",[e("strong",[t._v("brother1.vue:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  computed: {\n      gameList(){\n          return this.$store.state.gameList\n      }\n  }\n")])])]),e("p",[t._v("这样就完成了读取的操作。")]),t._v(" "),e("p",[e("strong",[t._v("效果：")])]),t._v(" "),e("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f6300db04884a2f9bad697d6da45571~tplv-k3u1fbpfcp-watermark.image?",alt:"img.png",referrerpolicy:"no-referrer"}}),t._v(" "),e("p",[t._v("现在如果我要在 brother2 中修改 brother1 的数据，该如何完成呢？")]),t._v(" "),e("p",[t._v("1.我们先在 brother2 中添加一个按钮绑定事件。")]),t._v(" "),e("p",[t._v("2.在 store 配置文件中为 mutations 配置项添加对应函数")]),t._v(" "),e("p",[e("strong",[t._v("brother2.vue:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(' methods: {\n     //button按钮绑定事件\n   changeValue(){  \n    //将其直接提交到store配置项mutations的changeBrother1方法下\n     this.$store.commit("changeBrother1","Q宠大乐斗")\n   }\n }\n')])])]),e("p",[e("strong",[t._v("store.js:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const mutations = {\n  //mutations配置项有两个参数state即代理了store下的state，value为外部组件传入的参数\n  changeBrother1(state, value) {\n    //这里把数组第一项变为我们brother2传入的“Q宠大乐斗”\n    //注意vue监测数组的变化要凭借数组方法\n    state.gameList.splice(0, 1, value);\n  }\n};\n")])])]),e("p",[e("strong",[t._v("效果：")])]),t._v(" "),e("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a551cc3dc7c1482382612247c20641a3~tplv-k3u1fbpfcp-watermark.image?",alt:"img.png",referrerpolicy:"no-referrer"}}),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("好了，到这里 vuex 的基本使用方法我们就说完了，下一期我们将会继续针对 vuex 来进行一些简化及进阶的操作。")])])}),[],!1,null,null,null);e.default=s.exports}}]);