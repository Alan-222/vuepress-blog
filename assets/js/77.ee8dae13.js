(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{484:function(e,t,n){"use strict";n.r(t);var s=n(2),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[t("code",[e._v("Redux")]),e._v("基本状态管理与"),t("code",[e._v("Axios")]),e._v("接口请求封装完成后，我们就可以进行"),t("code",[e._v("Redux")]),e._v("异步操作然后根据其结果修改全局状态。在本系统的实际应用是通过登录接口缓存 token 信息到"),t("code",[e._v("Redux")]),e._v("的 state 中，当这个 token 过期的时候会返回 401，在"),t("code",[e._v("axios")]),e._v("实例的响应拦截器中拦截到后进行"),t("code",[e._v("刷新token")]),e._v("的操作以此实现页面无感刷新。还有就是登录进入系统以后异步请求用户信息进行存储。接下来我们来看看具体的实现过程。")]),e._v(" "),t("h2",{attrs:{id:"redux-异步操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redux-异步操作"}},[e._v("#")]),e._v(" Redux 异步操作")]),e._v(" "),t("p",[e._v("通常在 Redux 中需要进行异步操作的话，我们需要 Redux-Thunk 中间件。")]),e._v(" "),t("blockquote",[t("p",[e._v("Redux Thunk 是一个中间件,允许在 Redux action 中返回函数而不仅仅是纯对象。这使得我们能够在 action 中进行异步操作，并在操作完成后分发一个新的 action。")])]),e._v(" "),t("p",[e._v("但"),t("code",[e._v("Redux-Toolkit")]),e._v("工具包已经内置了 thunk 插件，不需要再单独安装"),t("code",[e._v("Redux-Thunk")]),e._v("中间件，可以直接处理异步的 action。接下来我们直接编写登录的异步方法。")]),e._v(" "),t("h3",{attrs:{id:"登录的异步方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#登录的异步方法"}},[e._v("#")]),e._v(" 登录的异步方法")]),e._v(" "),t("h4",{attrs:{id:"实现异步更新用户信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现异步更新用户信息"}},[e._v("#")]),e._v(" 实现异步更新用户信息")]),e._v(" "),t("p",[e._v("1.导入从浏览器"),t("code",[e._v("localStorage")]),e._v("获取以及存储 token、refreshToken 的方法")]),e._v(" "),t("p",[t("strong",[e._v("src/store/reducers/userSlice.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import { getRefreshToken, getToken, removeRefreshToken, removeToken, setRefreshToken, setToken } from '@/utils/auth'\n")])])]),t("p",[e._v("2.导入登录和获取用户信息的接口")]),e._v(" "),t("p",[t("strong",[e._v("登录成功返回")]),e._v("："),t("code",[e._v("token、refreshToken")])]),e._v(" "),t("p",[t("strong",[e._v("获取用户信息成功返回")]),e._v("：用户名、头像等等")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import userApi from '@/api/user'\n")])])]),t("p",[e._v("3.编写登录和登出的同步 action。"),t("strong",[e._v("作用为")]),e._v("更新 state 中的"),t("code",[e._v("token")]),e._v("和"),t("code",[e._v("refreshToken")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("...\nreducers: {\n    login(state, action) {\n      state.token = action.payload.token\n      state.refreshToken = action.payload.refreshToken\n      // 将数据持久化\n      setToken(state.token)\n      setRefreshToken(state.refreshToken)\n    },\n    logout(state, action) {\n      state.token = null\n      state.refreshToken = null\n      state.userinfo = null\n      // 移除存储中的信息\n      removeToken()\n      removeRefreshToken()\n    }\n}\n...\n")])])]),t("p",[e._v("4.编写获取用户信息的异步方法。作用为更新用户状态（数据）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("...\n// 导出经过redux包装的action对象\nexport const { login, setUserinfo,logout } = userSlice.actions\n// 导出获取登录用户信息的异步方法\nexport const getUserInfoAsync = () => async (dispatch) => {\n  const { data } = await userApi.center.get()\n  dispatch(setUserinfo({ ...data, avatar: data.avatar ? process.env.React_APP_IMG_API + '/' + data.avatar : null }))\n  return data\n}\n")])])]),t("blockquote",[t("p",[t("code",[e._v("process.env.React_APP_IMG_API")]),e._v("环境变量为本人设置的访问图片的前缀，加上"),t("code",[e._v("data.avatar")]),e._v("即为完整的头像图片地址。可以在"),t("code",[e._v(".env.development")]),e._v("和"),t("code",[e._v(".env.production")]),e._v("文件中配置，分别为开发和生产环境。本文示例开发环境地址为"),t("a",{attrs:{href:"http://127.0.0.1:9999/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://127.0.0.1:9999"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("5.编写登录的异步 action。"),t("strong",[e._v("作用为")]),e._v("调用登录及获取登录的用户信息的接口，并分发同步的登录方法更新 token、refreshToken 状态")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("...\n// 登录异步方法\nexport const loginAsync = (payload) => async (dispatch) => {\n  const { data } = await userApi.login.login(payload)\n  dispatch(login(data))\n  await dispatch(getUserInfoAsync())\n}\n")])])]),t("p",[e._v("但我们还少了一个步骤，即获取登录用户的角色后，还要对角色的菜单和按钮权限进行处理，处理成"),t("code",[e._v("React router")]),e._v("能识别的格式才可以正常地访问系统。对于这部分有问题的可以访问"),t("a",{attrs:{href:"https://juejin.cn/post/7283642910301880372",target:"_blank",rel:"noopener noreferrer"}},[e._v("系统简介及设计"),t("OutboundLink")],1),e._v("。这里我们要新加一个"),t("strong",[e._v("Redux 切片")]),e._v("来处理权限【菜单、按钮】的状态。")]),e._v(" "),t("h3",{attrs:{id:"新增-redux-切片处理用户权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新增-redux-切片处理用户权限"}},[e._v("#")]),e._v(" 新增 Redux 切片处理用户权限")]),e._v(" "),t("p",[e._v("我们在 store 下的 reducers 文件夹新建"),t("code",[e._v("permissionSlice.js")]),e._v("文件，在这里我们来处理服务器返回的权限数组。我们先来看看服务器返回的数据结构")]),e._v(" "),t("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d05b46d52f941759cc32ae43842f4dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=798&h=678&s=48258&e=png&b=ffffff",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),t("p",[e._v("大概就是形如如下的结构（title 代表页签显示的标题、comonent 为 src 下 pages 后拼接的组件地址,children 为下一级导航的路由）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("[\n  {menu_id:40,title:'系统管理',component:\"Layout\",children:[{menu_id:xx,title:'xx'}]}\n  {xxxxx,children:[xxx]}\n]\n")])])]),t("p",[e._v("而正常"),t("code",[e._v("React-Router")]),e._v("的路由结构如下所示")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("[\n  // 访问/时重定向到/home\n  {\n    path: '/',\n    element: <Layout />,\n    children: [\n      { index: true, element: <Navigate to=\"/home\" replace /> },\n      { path: 'home', element: <Home /> },\n      {\n        path: 'system',\n        element: <System />,\n        children: [\n          { index: true, element: <Navigate to=\"/system/user\" replace /> },\n          { path: 'user', element: <User /> },\n          { path: 'role', element: <Role /> },\n          { path: 'auth', element: <Auth /> }\n     ]\n   }\n ]\n")])])]),t("p",[e._v("我们要创建一个切片将服务器返回的数据转为如上的路由结构。但是现在的路由还全是静态的，我们得先改造一下，在"),t("code",[e._v("React-Router")]),e._v("的配置文件里只暴露静态路由【无需权限就可访问的路由】，在切片中再进行静态和动态路由的拼接。")]),e._v(" "),t("h3",{attrs:{id:"改造路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#改造路由"}},[e._v("#")]),e._v(" 改造路由")]),e._v(" "),t("p",[e._v("在本系统中，静态的路由只包含登陆路由和首页。同时，我们还应该将未匹配的 url 全部跳转 404 页面。具体的路由结构如下所示：")]),e._v(" "),t("p",[t("strong",[e._v("src/router/index.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import { lazy } from 'react'\nimport { Navigate } from 'react-router-dom'\n// 用路由懒加载优化加载性能\nconst Layout = lazy(() => import('/Layout'))\nconst Home = lazy(() => import('@/pages/Home'))\nconst Login = lazy(() => import('@/pages/Login'))\nconst NotFound = lazy(() => import('@/pages/NotFound'))\n​\nconst constantRoutes = [\n  { path: 'login', title: '登录', element: <Login /> },\n  {\n    path: '/',\n    title: '首页',\n    hidden: true,\n    element: <Layout />,\n    children: [\n      { index: true, element: <Navigate to={'/home'} replace /> },\n      // hidden:false代表要显示在侧边导航栏，其余皆不显示\n      { path: 'home', title: '首页', element: <Home />, hidden: false }\n    ]\n  },\n  { path: '*', title: '404页面', element: <NotFound /> }\n]\nexport default constantRoutes\n")])])]),t("h3",{attrs:{id:"创建用户权限切片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建用户权限切片"}},[e._v("#")]),e._v(" 创建用户权限切片")]),e._v(" "),t("h4",{attrs:{id:"基本结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本结构"}},[e._v("#")]),e._v(" 基本结构")]),e._v(" "),t("p",[e._v("首先我们先编写正常的切片代码，在 initialState 中要存储两个路由数组，一个是完整的路由数组（包括静态的路由和权限路由），一个只包含权限路由。再编写对应的 reducer 处理方法。")]),e._v(" "),t("p",[t("strong",[e._v("src/store/reducers/permissionSlice.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import { createSlice } from '@reduxjs/toolkit'\nimport  constantRoutes from '@/router'\nconst permissionSlice = createSlice({\n  name: 'permission',\n  initialState: {\n    // routers默认为静态路由，之后拼接上服务器返回动态路由\n    routes: constantRoutes,\n    permissionRoutes: []\n  },\n  reducers: {\n    setRoutes(state, action) {\n      state.routes = constantRoutes.map((item) => {\n      // 嵌套在layout路由children下\n        if (item.path === '/') {\n          return { ...item, children: item.children.concat(action.payload.routes) }\n        }\n        return item\n      })\n    },\n    setPermissionRoutes(state, action) {\n      state.permissionRoutes = action.payload.routes\n    }，\n  }\n})\nexport const { setRoutes, setPermissionRoutes } = permissionSlice.actions\nexport default permissionSlice\n")])])]),t("h4",{attrs:{id:"转换路由结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转换路由结构"}},[e._v("#")]),e._v(" 转换路由结构")]),e._v(" "),t("p",[e._v("我们单独写一个递归函数（默认不知道有多少层级，所以要递归）来处理服务器返回的结构。主要的作用就是将后端返回的菜单数组转换为 Router Router 的路由结构。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import { lazy } from 'react'\n// 得到后端路由经转换后的路由结构\nfunction filterAsyncRoutes(routes) {\n  const res = []\n  // 遍历得到的路由转换为前端router结构\n  routes.forEach((route) => {\n   // 页面路由懒加载\n    const Component = lazy(() => import(`@/pages${route.component}`))\n    const tmp = {\n      path: route.path,\n      // 若为Layout则直接用父路由的Layout结构，否则用src/pages目录去拼接\n      element: route.component === 'Layout' ? null : <Component />,\n      redirect: route.redirect || undefined,\n      title: route.title,\n      // 将Number类型hidden转为Boolean\n      hidden: !!Number(route.hidden),\n      children: route.children || undefined\n    }\n    if (route.icon) {\n      tmp.icon = route.icon\n    }\n    if (tmp.children && tmp.children.length) {\n      tmp.children = route.redirect\n        ? [{ index: true, element: <Navigate to={route.redirect} replace /> }].concat(filterAsyncRoutes(tmp.children))\n        : filterAsyncRoutes(tmp.children)\n      // tmp.children = filterAsyncRoutes(tmp.children)\n    }\n    res.push(tmp)\n  })\n  return res\n}\n")])])]),t("h4",{attrs:{id:"编写异步方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写异步方法"}},[e._v("#")]),e._v(" 编写异步方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("export const generateRoutes = (payload) => (dispatch) => {\n  const accessedRoutes = filterAsyncRoutes(payload)\n  // 分发全局路由状态（静态 + 动态）\n  dispatch(setRoutes({ routes: accessedRoutes }))\n  // 分发动态路由\n  dispatch(setPermissionRoutes({ routes: accessedRoutes }))\n  return accessedRoutes\n}\n")])])]),t("h4",{attrs:{id:"添加进-store"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加进-store"}},[e._v("#")]),e._v(" 添加进 store")]),e._v(" "),t("p",[t("strong",[e._v("src/store/index.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("...\nimport permissionSlice from './reducers/permissionSlice'\n// 创建store对象\nconst store = configureStore({\n  reducer: {\n    user: userSlice.reducer,\n    permission: permissionSlice.reducer\n  }\n})\n...\n")])])]),t("h3",{attrs:{id:"修改-userslice-登录的异步方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修改-userslice-登录的异步方法"}},[e._v("#")]),e._v(" 修改 userSlice 登录的异步方法")]),e._v(" "),t("p",[t("strong",[e._v("src/reducers/userSlice.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 导入加载用户路由的方法\nimport { generateRoutes } from './permissionSlice'\n...\n// 登录异步方法\nexport const loginAsync = (payload) => async (dispatch) => {\n  const { data } = await userApi.login.login(payload)\n  dispatch(login(data))\n+  const userinfo = await dispatch(getUserInfoAsync())\n+  dispatch(generateRoutes(userinfo.menus))\n}\n...\n")])])]),t("h3",{attrs:{id:"修改入口组件-app-jsx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修改入口组件-app-jsx"}},[e._v("#")]),e._v(" 修改入口组件 App.jsx")]),e._v(" "),t("p",[e._v("我们完成两个切片"),t("code",[e._v("userSlice")]),e._v("和"),t("code",[e._v("permissionSlice")]),e._v("的编写后，就可以在页面中进行分发 action 进行全局状态的存储与使用。")]),e._v(" "),t("p",[e._v("大致修改流程如下：")]),e._v(" "),t("p",[e._v("1.判断浏览器"),t("code",[e._v("localStorage")]),e._v("是否存在 token")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("存在，则获取当前用户的信息，并加载当前用户的路由")])]),e._v(" "),t("li",[t("p",[e._v("不存在，则跳到登录页面让其登录，登录后再执行上一步操作")]),e._v(" "),t("p",[e._v("2.编写 Loading 组件，这里用到了 Antd 提供的 Spin 组件")])])]),e._v(" "),t("blockquote",[t("p",[e._v("由于使用了 React 的路由动态加载 lazy，其需要在 React.Suspense 组件下进行渲染，Suspense 又支持传入 fallback 属性，作为动态加载模块完成前组件渲染的内容。")])]),e._v(" "),t("p",[t("strong",[e._v("src/components/Loading/index.jsx")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import { Spin } from 'antd'\nimport './Loading.scss'\nexport default function Loading(props) {\n  let { loadingText = '数据加载中...' } = props\n​\n  return (\n    <div className=\"Loading\">\n      <Spin size=\"large\" />\n      <h3 className=\"loadingText\">{loadingText}</h3>\n    </div>\n  )\n}\n")])])]),t("p",[t("strong",[e._v("src/components/Loading/Loading.scss")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(".Loading{\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  background: rgba(0, 0, 0, 0.05);\n  .loadingText{\n    color: #408fff;\n  }\n}\n")])])]),t("p",[e._v("3.根组件 App 修改如下")]),e._v(" "),t("p",[t("strong",[e._v("src/App.jsx")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import React, { Suspense, useEffect } from 'react'\n// 导入路由及react-redux钩子\nimport { useNavigate, useRoutes } from 'react-router-dom'\nimport { useDispatch, useSelector } from 'react-redux'\n// 导入api\nimport { getUserInfoAsync } from './store/reducers/userSlice'\nimport { generateRoutes } from './store/reducers/permissionSlice'\nimport { getToken } from './utils/auth'\n// 导入loading组件\nimport Loading from '@/components/Loading'\n​\nexport default function App() {\n  // redux hook\n  const dispatch = useDispatch()\n  const routes = useSelector((state) => state.permission.routes)\n  // 跳转方法\n  const navigate = useNavigate()\n​\n  useEffect(() => {\n    const fetchData = async () => {\n      if (getToken()) {\n        const userInfo = await dispatch(getUserInfoAsync())\n        dispatch(generateRoutes(userInfo.menus))\n      } else {\n        navigate('/login', { replace: true })\n      }\n    }\n    fetchData()\n  }, [dispatch])\n  // 利用hook转换路由表\n  const element = useRoutes(routes)\n  return (\n    <>\n      <Suspense fallback={<Loading />}>{routes && element}</Suspense>\n    </>\n  )\n}\n")])])]),t("h2",{attrs:{id:"测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[e._v("#")]),e._v(" 测试")]),e._v(" "),t("p",[e._v("由于我们登录页面还没实现，我们先通过接口测试工具简单测试一下（这里以 postman 为例）")]),e._v(" "),t("h3",{attrs:{id:"获取验证码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取验证码"}},[e._v("#")]),e._v(" 获取验证码")]),e._v(" "),t("p",[e._v("注意，这步需要安装好"),t("code",[e._v("Redis")]),e._v("！然后参考"),t("a",{attrs:{href:"https://juejin.cn/post/7293289855076335656",target:"_blank",rel:"noopener noreferrer"}},[e._v("从零实现一个 React+Antd5.0 后台管理系统-接口请求封装"),t("OutboundLink")],1),t("strong",[e._v("所需准备")]),e._v("中的接口文档输入请求 url 和请求参数")]),e._v(" "),t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b877c7b689174a53b47f9b08c3a27b0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1165&h=760&s=70112&e=png&b=fff6f6",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),t("h3",{attrs:{id:"登录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#登录"}},[e._v("#")]),e._v(" 登录")]),e._v(" "),t("h4",{attrs:{id:"命令行获取验证码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令行获取验证码"}},[e._v("#")]),e._v(" 命令行获取验证码")]),e._v(" "),t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96db78aa7c8f412792d90736fe049880~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=502&h=304&s=17592&e=png&b=0d0d0d",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),t("h4",{attrs:{id:"测试-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试-2"}},[e._v("#")]),e._v(" 测试")]),e._v(" "),t("p",[e._v("用刚刚自定义的 uuid 和默认账号：Alan 密码：123456（需要添加账号可以用登录获取的 token 放在请求头中去添加）")]),e._v(" "),t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d8404db972477aa551234086341248~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1185&h=810&s=93941&e=png&b=fefefe",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),t("p",[e._v("然后把获取到的 token 放到浏览器的 localStorage 中")]),e._v(" "),t("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c49d2594e50f4817a71992296f8b28bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1041&h=298&s=28152&e=png&b=fdfdfd",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),t("p",[e._v("刷新即可进入首页，点击系统管理重定向至用户管理的路由")]),e._v(" "),t("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7493ac15fa35463ca96ccc7884568739~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2559&h=979&s=182377&e=png&b=fef9f9",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),t("p",[e._v("但因为我们在转化后端路由的时候把 element 设为组件了，是个 Symbol 类型的数据，所以没有通过"),t("code",[e._v("redux")]),e._v(" 的数据序列化检查，我们在 store 中添加中间件配置把它关掉即可。")]),e._v(" "),t("p",[t("strong",[e._v("src/store/index.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("...\nconst store = configureStore({\n  reducer: {\n    user: userSlice.reducer,\n    permission: permissionSlice.reducer\n  },\n+  middleware: (getDefaultMiddleware) =>\n+    getDefaultMiddleware({\n+      //关闭redux序列化检测\n+      serializableCheck: false\n    })\n})\n...\n")])])]),t("p",[e._v("到这里我们的测试就算成功了，完成了 Redux 异步操作用户信息。但是还有一点，我们存储在"),t("strong",[e._v("localStorage")]),e._v("中的 token 传到后端检测后会存在"),t("strong",[e._v("过期返回状态码 401")]),e._v("的现象，所以我们在"),t("code",[e._v("axios")]),e._v("拦截器拦截到这个状态码的时候要刷新一下 token，并重新载入因过期未执行的接口。")]),e._v(" "),t("h2",{attrs:{id:"axios-响应拦截器中刷新-token"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios-响应拦截器中刷新-token"}},[e._v("#")]),e._v(" Axios 响应拦截器中刷新 token")]),e._v(" "),t("p",[e._v("现在响应拦截器中无非就两种情况，当状态码为 0 的时候表示响应成功正常返回数据，当不为 0 的时候判断是否为"),t("strong",[e._v("401")]),e._v("，如果是的话就刷新 token 并执行未响应队列。")]),e._v(" "),t("p",[t("strong",[e._v("src/utils/request.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import store from '../store'\nimport { setToken, setRefreshToken } from '../utils/auth'\nimport { login } from '../store/reducers/userSlice'\nimport { logout } from '@/store/reducers/userSlice'\n​\n...\n​\n// 是否正在刷新的标记\nlet isRefreshing = false\n// 重试队列，每一项将是一个待执行的函数形式\nlet requests = []\n// 添加响应拦截器\ninstance.interceptors.response.use(\n  (response) => {\n    // 如果返回的类型为二进制文件类型\n    if (response.config.responseType === 'blob') {\n      if (response.status !== 200) {\n        message.error('请求失败' + response.status)\n        return Promise.reject()\n      } else if (!response.headers['content-disposition']) {\n        message.error('暂无接口访问权限')\n        return Promise.reject()\n      }\n      return response\n    } else {\n      // 如果接口请求失败\n      if (response.data.code !== 0) {\n        let errMsg = response.data.message || '系统错误'\n        // token过期\n        if (response.data.code === 401) {\n          const config = response.config\n          // token失效,判断请求状态\n          if (!isRefreshing) {\n            isRefreshing = true\n            // 刷新token\n            return Axios({\n              url: 'http://127.0.0.1:9999/user/refreshToken',\n              method: 'POST',\n              data: { refreshToken: store.getState().user.refreshToken }\n            })\n              .then((res) => {\n                // 刷新token成功，更新最新token\n                const { token, refreshToken } = res.data.data\n                store.dispatch(login({ token, refreshToken }))\n                setToken(token)\n                setRefreshToken(refreshToken)\n                //已经刷新了token，将所有队列中的请求进行重试\n                requests.forEach((cb) => {\n                  cb(token)\n                })\n                // 重试完了别忘了清空这个队列\n                requests = []\n                return instance({\n                  ...config,\n                  headers: {\n                    ...config.headers,\n                    Authorization: token\n                  }\n                })\n              })\n              .catch((e) => {\n                store.dispatch(logout())\n                // 重置token失败，跳转登录页\n                console.log(e.message)\n                window.location.href = '/login'\n              })\n              .finally(() => {\n                isRefreshing = false\n              })\n          } else {\n            // 返回未执行 resolve 的 Promise\n            return new Promise((resolve) => {\n              // 用函数形式将 resolve 存入，等待刷新后再执行\n              requests.push((token) => {\n                config.baseURL = '/api'\n                config.headers && (config.headers['Authorization'] = token)\n                resolve(\n                  instance({\n                    ...config,\n                    headers: {\n                      ...config.headers,\n                      Authorization: token\n                    }\n                  })\n                )\n              })\n            })\n          }\n        } else {\n          message.error(errMsg)\n        }\n        return Promise.reject(errMsg)\n      }\n      return response.data\n    }\n  },\n  (error) => {\n    return Promise.reject(error)\n  }\n)\n")])])]),t("p",[e._v("然后，不出意外的话就会报错，原因是我们循环引用了（在切片中我们异步代码用的是"),t("code",[e._v("axios")]),e._v("封装的接口，然后我们又在"),t("code",[e._v("axios")]),e._v("封装文件中将 store 引入造成了循环引用）")]),e._v(" "),t("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/101a3216e0734c0cb749b1a0dff6235e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1486&h=963&s=154522&e=png&b=2b171a",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),t("p",[e._v("要解决也很简单，我在入口文件里面引用不就好了，在 axios 我就抛出一个方法执行响应拦截器的方法。")]),e._v(" "),t("p",[t("strong",[e._v("src/utils/request.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import store from '../store'\nimport { setToken, setRefreshToken } from '../utils/auth'\nimport { login } from '../store/reducers/userSlice'\nimport { logout } from '@/store/reducers/userSlice'\nexport function setResponseInterceptor(store, login, logout) {\n  // 填写上面的响应拦截器代码\n  ...\n}\n")])])]),t("p",[t("strong",[e._v("src/index.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("...\nimport store from './store'\nimport { login, logout } from './store/reducers/userSlice'\n// 导入axios的响应拦截器方法\nimport { setResponseInterceptor } from './utils/request'\n// 设置axios的响应拦截器\nsetResponseInterceptor(store, login, logout)\n...\n")])])]),t("p",[e._v("这样就设置成功，也能够进行 token 的刷新操作。")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("本篇文章我们完成了"),t("strong",[e._v("Redux 异步操作")]),e._v("和"),t("strong",[e._v("Axios 响应拦截器刷新 token")]),e._v("。主要涉及到的知识有")]),e._v(" "),t("p",[e._v("1.在切片文件中导出异步函数，并在组件中导入后进行 dispatch 分发")]),e._v(" "),t("p",[e._v("2.如何进行路由动态加载（懒加载），并用"),t("code",[e._v("React.Suspense")]),e._v("包裹")]),e._v(" "),t("p",[e._v("3.如何在 axios 响应拦截器中刷新 token")]),e._v(" "),t("p",[e._v("4.用户路由如何动态生成路由表，并用 useRoutes hook 转换")]),e._v(" "),t("h2",{attrs:{id:"代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码"}},[e._v("#")]),e._v(" 代码")]),e._v(" "),t("p",[e._v("上述实现的代码都放在"),t("a",{attrs:{href:"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FAlan-222%2Freact-antd5-admin",title:"https://github.com/Alan-222/react-antd5-admin",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-antd5-admin"),t("OutboundLink")],1),e._v("，大家可自行查阅")])])}),[],!1,null,null,null);t.default=r.exports}}]);