(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{473:function(e,n,t){"use strict";t.r(n);var i=t(2),a=Object(i.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),n("p",[e._v("完成了用户和角色路由的编写，接下来就要完成权限的编写，即权限菜单与权限按钮。但我们首先明确一下这三者之间的关系。一个用户拥有多个角色，每个角色又有多个权限，所以要建立一个角色权限表以便存储两者之间的关系，除此之外还需要建立一个权限表。")]),e._v(" "),n("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d6ddf061c024d25b4807591453e428f~tplv-k3u1fbpfcp-watermark.image?",alt:"img.png",referrerpolicy:"no-referrer"}}),e._v(" "),n("p",[n("strong",[e._v("sql")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("SET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n​\n-- ----------------------------\n-- Table structure for menus\n-- ----------------------------\nDROP TABLE IF EXISTS `menus`;\nCREATE TABLE `menus`  (\n  `menu_id` int UNSIGNED NOT NULL AUTO_INCREMENT,\n  `parent_id` int NOT NULL COMMENT '上级ID',\n  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标题',\n  `sort` int NOT NULL DEFAULT 0 COMMENT '排序',\n  `type` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '类型',\n  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图标',\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '路由名称',\n  `component` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '路由组件',\n  `path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '路由地址',\n  `redirect` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '跳转地址',\n  `permission` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限标识',\n  `hidden` tinyint(1) NULL DEFAULT NULL COMMENT '隐藏',\n  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',\n  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  PRIMARY KEY (`menu_id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;\n​\n-- ----------------------------\n-- Table structure for roles_menus\n-- ----------------------------\nDROP TABLE IF EXISTS `roles_menus`;\nCREATE TABLE `roles_menus`  (\n  `role_menu_id` int UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '角色菜单联合表id',\n  `role_id` int NOT NULL COMMENT '角色id',\n  `menu_id` int NOT NULL COMMENT '菜单id',\n  `create_time` datetime NOT NULL COMMENT '创建时间',\n  PRIMARY KEY (`role_menu_id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;\n\nSET FOREIGN_KEY_CHECKS = 1;\n")])])]),n("h2",{attrs:{id:"建立权限模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#建立权限模型"}},[e._v("#")]),e._v(" 建立权限模型")]),e._v(" "),n("p",[e._v("首先还是依据数据库字段一一对应构造模型。这里重点说明一下，每个权限（菜单+按钮）都有对应的父级 id（若是顶级菜单则父 id 为 0），然后按照 type 字段为"),n("code",[e._v("'C'")]),e._v("目录、"),n("code",[e._v("'M'")]),e._v("菜单、为"),n("code",[e._v("'B'")]),e._v("按钮区分出菜单及按钮。path、component 对应 vue 路由中的 path 路由路径和 component 路由地址（文件地址）。sort 是菜单的排列顺序，hidden 字段则是是否在 vue 前端的菜单栏中显示。")]),e._v(" "),n("p",[n("strong",[e._v("model/menus.js")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const Sequelize = require('sequelize');\nconst moment = require('moment');\nconst sequelize = require('./init');\nconst { Op } = Sequelize;\n// 定义表的模型\nconst MenusModel = sequelize.define('menus', {\n  menu_id: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  parent_id: {\n    type: Sequelize.INTEGER,\n    defaultValue: 0\n  },\n  title: {\n    type: Sequelize.STRING(255),\n    defaultValue: ''\n  },\n  sort: {\n    type: Sequelize.INTEGER,\n    defaultValue: 0\n  },\n  type: {\n    type: Sequelize.CHAR(1),\n    defaultValue: 'C'\n  },\n  icon: {\n    type: Sequelize.STRING(255)\n  },\n  name: {\n    type: Sequelize.STRING(255)\n  },\n  component: {\n    type: Sequelize.STRING(255)\n  },\n  path: {\n    type: Sequelize.STRING(255)\n  },\n  permission: {\n    type: Sequelize.STRING(255)\n  },\n  redirect: {\n    type: Sequelize.STRING(255)\n  },\n  hidden: {\n    type: Sequelize.TINYINT(1),\n    defaultValue: 0\n  },\n  update_time: {\n    type: Sequelize.DATE,\n    get() {\n      return this.getDataValue('update_time')\n        ? moment(this.getDataValue('update_time')).format('YYYY-MM-DD HH:mm:ss')\n        : null;\n    }\n  },\n  create_time: {\n    type: Sequelize.DATE,\n    defaultValue: Sequelize.NOW,\n    get() {\n      return moment(this.getDataValue('create_time')).format('YYYY-MM-DD HH:mm:ss');\n    }\n  }\n});\n// 导出菜单模型\nmodule.exports = MenusModel;\n")])])]),n("p",[e._v("而角色权限表只需要在表中通过二者的 id 来存储关系即可。")]),e._v(" "),n("p",[n("strong",[e._v("model/roles-menus.js")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const Sequelize = require('sequelize');\nconst moment = require('moment');\nconst sequelize = require('./init');\n\n// 定义表的模型\nconst RolesMenusModel = sequelize.define('roles_menus', {\n  role_menu_id: {\n    type: Sequelize.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  role_id: {\n    type: Sequelize.INTEGER\n  },\n  menu_id: {\n    type: Sequelize.INTEGER\n  },\n  create_time: {\n    type: Sequelize.DATE,\n    defaultValue: Sequelize.NOW,\n    get() {\n      return moment(this.getDataValue('create_time')).format('YYYY-MM-DD HH:mm:ss');\n    }\n  }\n});\n\nmodule.exports = RolesMenusModel;\n\n")])])]),n("h2",{attrs:{id:"获取权限的树状结构数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#获取权限的树状结构数据"}},[e._v("#")]),e._v(" 获取权限的树状结构数据")]),e._v(" "),n("p",[e._v("在获取表中数据时，要依据父菜单 id 来组成类似如下所示的结构：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n  title,\n  path,\n  component,\n  children:[\n    {\n       title\n       ...\n    },{...}\n  ]\n  ...\n},\n{\n  title,\n  ...\n  children\n}\n")])])]),n("p",[e._v("若父 id 为 0，则为顶级菜单。其余若父 id 为其它菜单的 id 则为其孩子，以此类推。所以我们得写一个方法来构造此结构。分三个步骤")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("先在表中查询取出所有菜单项包括按钮项的元数据。（元数据的意思是 sequelize 查询出来除了数据集 sequelize 可能还包装了一些配置属性）")])]),e._v(" "),n("li",[n("p",[e._v("通过 plain 属性将元数据转换为只有第一项的数据集")]),e._v(" "),n("blockquote",[n("p",[e._v("如果 plain 为 true,则 sequelize 将仅返回结果集的第一条记录. 如果是 false,它将返回所有记录.")])])]),e._v(" "),n("li",[n("p",[e._v("将数据集转换为树状结构")])])]),e._v(" "),n("p",[n("strong",[e._v("model/menus.js")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("...\nconst MenusModel = sequelize.define(...)\n// 获得权限的树状数据结构\nMenusModel.getListTree = async function (where = {}) {\n  let menus = [];\n  // 查询数据库获得元数据\n  // 有标题入参时\n  if (where.title) {\n    menus = await MenusModel.findAll({\n      where: {\n        title: {\n          [Op.like]: `%${where.title}%`\n        }\n      },\n      order: [['sort']]\n    });\n  } else {\n    menus = await MenusModel.findAll({\n      order: [['sort']]\n    });\n  }\n  // 将元数据转换为单纯的数据集\n  const menusArr = menus.map(function (item) {\n    return item.get({ plain: true });\n  });\n  // 将数据集转换为树状结构\n  return tools.getTreeData(menusArr, null, 'menu_id');\n};\n...\n")])])]),n("p",[e._v("将获取树状结构的方法封装成公共工具方法，便于调用。我们现在已经得到了按 sort 升序排列的权限数组。之后我们做到以下几个步骤。")]),e._v(" "),n("ul",[n("li",[e._v("第一次进去先获取所有数据的"),n("strong",[e._v("父 id")]),e._v("，然后得到最小的父 id（一般为 0），对上面权限数组遍历菜单 id 为此最小父 id 的即为顶级菜单用一个数组存着。")]),e._v(" "),n("li",[e._v("然后我们能得到这些顶级菜单的菜单 id，我们再通过此递归调用查出它的子孩子（若有）")])]),e._v(" "),n("p",[e._v("下面我们用代码详细看看")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * 获取树形结构数据\n * @param data 数据\n * @param level 父id层级\n * @param idField 字段名\n * @param pidField 上一级字段名\n * @returns {null|[]}\n */\nconst getTreeData = function (data, level = null, idField = 'menu_id', pidField = 'parent_id') {\n  const tree = [];\n  const _level = [];\n  // 第一次进来获取所有父id\n  if (level === null) {\n    data.forEach(function (item) {\n      _level.push(item[pidField]);\n    });\n    level = Math.min(..._level);\n  }\n  data.forEach(function (item) {\n    if (item[pidField] === level) {\n      tree.push(item);\n    }\n  });\n  if (tree.length === 0) {\n    return null;\n  }\n​\n  // 对于父id为0的进行循环，然后查出父节点为上面结果id的节点内容\n  tree.forEach(function (item) {\n    if(item.type!=='B'){\n        const childData = getTreeData(data, item[idField], idField, pidField);\n        if (childData != null) {\n          item['children'] = childData;\n        }\n    }\n  });\n  return tree;\n};\n")])])]),n("p",[e._v("这样就能够得到权限的树状结构数据了。")])])}),[],!1,null,null,null);n.default=a.exports}}]);